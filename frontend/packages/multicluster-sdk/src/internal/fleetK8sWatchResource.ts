/* Copyright Contributors to the Open Cluster Management project */

/**
 * Cache for fleet resources.
 * The key is the request path, and the value is the resource data.
 */
export const fleetResourceCache: Record<string, any> = {}

/**
 * Cache for fleet WebSockets.
 * The key is a cache key generated by getCacheKey, and the value is the WebSocket instance.
 */
export const fleetSocketCache: Record<string, WebSocket> = {}

/**
 * Generates a cache key for a given resource.
 * @param model - The Kubernetes model for the resource.
 * @param cluster - The name of the cluster.
 * @param namespace - The namespace of the resource.
 * @param name - The name of the resource.
 * @returns A unique cache key string.
 */
export const getCacheKey = ({
  model,
  cluster,
  namespace,
  name,
}: {
  model: any
  cluster?: string
  namespace?: string
  name?: string
}) => {
  return [cluster, model?.apiVersion, model?.kind, namespace, name].join('|')
} /**
 * Clears the cache for fleet resources and closes any open WebSockets.
 */

export function clearFleetK8sWatchResourceCache() {
  Object.keys(fleetResourceCache).forEach((key) => delete fleetResourceCache[key])
  Object.values(fleetSocketCache).forEach((socket) => {
    if (socket.readyState === WebSocket.OPEN) {
      socket.close()
    }
  })
  Object.keys(fleetSocketCache).forEach((key) => delete fleetSocketCache[key])
}

export const handleWebsocketEvent = <R>(
  event: any,
  requestPath: string,
  setData: (data: R) => void,
  isList: boolean | undefined,
  fleetResourceCache: Record<string, any>,
  cluster: string
): void => {
  if (!event) {
    console.warn('Received undefined event', event)
    return
  }

  const eventDataParsed = JSON.parse(event.data)

  const eventType = eventDataParsed?.type
  const object = eventDataParsed?.object

  if (!object) return

  if (!isList) {
    if (eventType === 'ADDED' && fleetResourceCache[requestPath]) return

    const processedEventData = { cluster, ...(object as K8sResourceCommon) } as R

    if (processedEventData) {
      fleetResourceCache[requestPath] = processedEventData
      setData(processedEventData)
    }

    return
  }

  if (eventType === 'DELETED') {
    const storedData = fleetResourceCache[requestPath] as K8sResourceCommon[]
    const updatedData = storedData.filter((i) => i.metadata?.uid !== object?.metadata?.uid)
    fleetResourceCache[requestPath] = updatedData
    setData(updatedData as R)
    return
  }

  if (eventType !== 'ADDED' && eventType !== 'MODIFIED') {
    return
  }
  if (!object?.metadata?.uid) {
    console.warn('Event object does not have a metadata.uid', eventDataParsed)
    return
  }

  const storedData = fleetResourceCache[requestPath] as K8sResourceCommon[]

  const objectExists = storedData.some((i) => i.metadata?.uid === object?.metadata?.uid)

  if (objectExists && eventType === 'MODIFIED') {
    const updatedData = storedData.map((i) => (i.metadata?.uid === object?.metadata?.uid ? { cluster, ...object } : i))
    fleetResourceCache[requestPath] = updatedData
    setData(updatedData as R)
    return
  }

  if (!objectExists) {
    const updatedData = [...storedData, { cluster, ...(object as K8sResourceCommon) }] as R
    fleetResourceCache[requestPath] = updatedData
    setData(updatedData)
  }
}
